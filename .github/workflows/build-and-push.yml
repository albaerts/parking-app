name: Build and push Docker images to GHCR

on:
  push:
    branches: [ main, deploy/fix-db-nginx ]
  workflow_dispatch: {}

permissions:
  contents: read
  packages: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU (for cross-platform builds)
        uses: docker/setup-qemu-action@v2

      - name: Login to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./backend/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/parking-backend:latest
            ghcr.io/${{ github.repository_owner }}/parking-backend:${{ github.sha }}
          platforms: linux/amd64

      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./frontend/Dockerfile
          build-args: |
            COMMIT_SHA=${{ github.sha }}
          no-cache: true
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/parking-frontend:latest
            ghcr.io/${{ github.repository_owner }}/parking-frontend:${{ github.sha }}
          platforms: linux/amd64

  deploy:
    name: Deploy to VPS
    needs: build-and-push
    runs-on: ubuntu-latest
    # Run deploy on main and the deploy/fix-db-nginx branch
    if: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/deploy/fix-db-nginx' }}

    steps:
      - name: Deploy via SSH to VPS
        uses: appleboy/ssh-action@v0.1.8
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_SSH_PORT }}
          script: |
            set -euxo pipefail

            # Ensure IMAGE_TAG is defined (use current commit SHA)
            IMAGE_TAG='${{ github.sha }}'

            REMOTE_PATH="${{ secrets.DEPLOY_REMOTE_PATH }}"
            if [ -z "${REMOTE_PATH}" ]; then
              REMOTE_PATH="/var/www/parkingsrv"
            fi
            cd "${REMOTE_PATH}" || exit 1

            echo "=== Checking port bindings for 80/443 on host (to detect legacy nginx) ==="
            if command -v ss >/dev/null 2>&1; then
              ss -ltnp | (grep -E ":((80)|(443))\s" || true)
            else
              netstat -ltnp 2>/dev/null | (grep -E ":((80)|(443))\s" || true) || true
            fi

            # If legacy host nginx is active (binding 80/443), stop it to free the ports for the proxy container
            if command -v systemctl >/dev/null 2>&1; then
              if systemctl is-active --quiet nginx; then
                echo "Host nginx is active — stopping & disabling to free ports 80/443 for docker proxy"
                systemctl stop nginx || true
                systemctl disable nginx || true
                systemctl mask nginx || true
              else
                echo "Host nginx is not active"
              fi
            fi

            echo "=== Listing /var/www to check for legacy paths ==="
            ls -la /var/www || true

            echo "=== Attempting to stop legacy compose stack in /var/www/parking if present ==="
            if [ -d "/var/www/parking" ]; then
              LEGACY_DIR="/var/www/parking"
              # Detect docker-compose vs docker compose
              if command -v docker-compose >/dev/null 2>&1; then
                DC="docker-compose"
              elif docker compose version >/dev/null 2>&1; then
                DC="docker compose"
              else
                DC=""
              fi
              if [ -n "$DC" ]; then
                # Choose a compose file if available, default to docker-compose.yml
                LEGACY_COMPOSE_FILE=""
                for f in docker-compose.prod.yml docker-compose.yml docker-compose.yaml; do
                  if [ -f "$LEGACY_DIR/$f" ]; then
                    LEGACY_COMPOSE_FILE="$f"
                    break
                  fi
                done
                if [ -n "$LEGACY_COMPOSE_FILE" ]; then
                  echo "Stopping legacy stack at $LEGACY_DIR using $LEGACY_COMPOSE_FILE"
                  (cd "$LEGACY_DIR" && $DC -f "$LEGACY_COMPOSE_FILE" down --remove-orphans) || true
                else
                  echo "No compose file found in $LEGACY_DIR — skipping down"
                fi
              else
                echo "No docker compose CLI found on host to stop legacy stack — skipping"
              fi
            else
              echo "/var/www/parking does not exist — no legacy stack there"
            fi

            # If a GHCR token is provided, login so docker pull can authenticate (optional)
            if [ -n "${GHCR_PAT:-}" ]; then
              echo "Logging into ghcr.io"
              echo "${GHCR_PAT}" | docker login ghcr.io -u "${{ github.repository_owner }}" --password-stdin || true
            else
              echo "No GHCR_PAT provided — assuming images are public or host is already logged in"
            fi

            echo "Fetching latest repo and preparing deploy branch"
            if [ -d .git ]; then
              git fetch origin || true
              git branch -f backup-before-deploy-$(date +%s) || true
              BRANCH_NAME='${{ github.ref_name }}'
              git checkout -B deploy-$BRANCH_NAME origin/$BRANCH_NAME || true
              git rev-parse --abbrev-ref HEAD || true
              git log -n 1 --pretty=oneline || true
            else
              echo "Warning: ${REMOTE_PATH} is not a git repository; continuing with existing files"
            fi

            echo "Running deploy/update.sh with image tag $IMAGE_TAG"
            chmod +x ./deploy/update.sh || true
            IMAGE_TAG="$IMAGE_TAG" ./deploy/update.sh "$IMAGE_TAG"

            echo "=== Docker processes after compose up ==="
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' || true
            echo "=== Docker images for parking-* (top 10) ==="
            docker images | grep -E 'parking-(frontend|backend)' | head -n 10 || true
            echo "=== Listing deploy directory for diagnostics ==="
            ls -la ./deploy || true
            echo "=== Proxy container logs (first 40 lines) ==="
            if docker ps -q -f name=parking_proxy >/dev/null 2>&1; then
              docker logs --tail 40 parking_proxy || true
            else
              echo "parking_proxy container not running; attempting fallback static export to host nginx path (if nginx masked this will be skipped)."
              # Fallback: extract static frontend build for manual verification
              mkdir -p /var/www/parking_fallback
              docker create --name tmp_fe_export ghcr.io/${{ github.repository_owner }}/parking-frontend:$IMAGE_TAG || true
              if docker ps -a -q -f name=tmp_fe_export >/dev/null 2>&1; then
                docker cp tmp_fe_export:/usr/share/nginx/html/. /var/www/parking_fallback/ || true
                docker rm tmp_fe_export || true
                echo "Fallback static files exported to /var/www/parking_fallback (not served unless host nginx re-enabled)."
              fi
            fi

            echo "=== Frontend index.html hash from image vs running container ==="
            # Extract index.html from the exact image tag
            docker create --name fe_tmp ghcr.io/${{ github.repository_owner }}/parking-frontend:$IMAGE_TAG || true
            if docker ps -a -q -f name=fe_tmp >/dev/null 2>&1; then
              docker cp fe_tmp:/usr/share/nginx/html/index.html /tmp/index_from_image.html || true
              docker rm fe_tmp || true
              if [ -f /tmp/index_from_image.html ]; then
                echo "Image index.html sha256:"
                sha256sum /tmp/index_from_image.html || true
              else
                echo "Failed to copy index.html from image"
              fi
            fi

            if docker ps -q -f name=parking_frontend >/dev/null 2>&1; then
              echo "Running container index.html sha256:"
              docker exec parking_frontend sha256sum /usr/share/nginx/html/index.html || true
              echo "Writing version marker to running frontend container..."
              docker exec parking_frontend /bin/sh -c "echo '${{ github.sha }}' > /usr/share/nginx/html/version.txt" || true
            else
              echo "parking_frontend container not running — cannot compute hash or write version marker"
            fi

            # Run DB migration helper if present
            if [ -f ./deploy/migrate_db.sh ]; then
              chmod +x ./deploy/migrate_db.sh || true
              ./deploy/migrate_db.sh || true
            fi

            # Sanity check public site
            if command -v curl >/dev/null 2>&1; then
              echo "Running public site sanity check..."
              TMPFILE=$(mktemp)
              HTTP=$(curl -sL -w "%{http_code}" -o "$TMPFILE" "https://parking.gashis.ch/" || echo "000")
              echo "public_site_status=$HTTP"
              if [ "$HTTP" = "200" ]; then
                if grep -q "ParkingApp | Smart Parking Solutions" "$TMPFILE"; then
                  echo "Public site content check passed"
                else
                  echo "Public site content check FAILED - expected title not found" >&2
                  head -c 200 "$TMPFILE" >&2 || true
                  rm -f "$TMPFILE"
                  exit 4
                fi
              else
                echo "Public site check failed (status=$HTTP)" >&2
                rm -f "$TMPFILE"
                exit 3
              fi
              rm -f "$TMPFILE"

              echo "Checking live version marker..."
              LIVE_VER=$(curl -sS https://parking.gashis.ch/version.txt || true)
              echo "live_version_marker=$LIVE_VER"
              if [ -n "$LIVE_VER" ]; then
                if [ "$LIVE_VER" = "${{ github.sha }}" ]; then
                  echo "Live version marker matches current commit"
                else
                  echo "Live version marker does not match current commit: $LIVE_VER" >&2
                fi
              else
                echo "No live version marker available (first deploy with marker?)"
              fi
            else
              echo "curl not available on remote host — skipping public site check"
            fi
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT || secrets.DEPLOY_GHCR_TOKEN }}
